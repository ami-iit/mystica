function [data,stateDyn,stats] = runSimDynRel(input)
    arguments
        input.stgs                 struct
        input.model                mystica.model.Model
        input.mBodyPosQuat_0 (:,1) double
        input.nameControllerClass  char
    end

    mp = mystica.utils.MeasurePerformance();

    stgs            = input.stgs;
    model           = input.model;
    ClassController = str2func(input.nameControllerClass);

    %% Initialization

    tout  = 0 : stgs.integrator.maxTimeStep : stgs.integrator.limitMaximumTime;
    kVec  = 1 : length(tout);

    stateDyn = mystica.state.StateDynMBody(...
        'model',model,...
        'mBodyPosQuat_0',input.mBodyPosQuat_0,...
        'mBodyTwist_0',zeros(model.constants.mBodyTwist,1),...
        'stgsIntegrator',stgs.integrator,...
        'stgsStateDynMBody',stgs.stateDyn,...
        'stgsModel',stgs.model);

    contr = ClassController(...
        'model',model,...
        'stateDynMBody',stateDyn,...
        'stgsController',stgs.controller,....
        'stgsDesiredShape',stgs.desiredShape,...
        'time',0,...
        'controller_dt',stgs.integrator.maxTimeStep);

    intgr = mystica.intgr.IntegratorDynRel(...
        'dt',stgs.integrator.maxTimeStep,...
        'stgsIntegrator',stgs.integrator);

    noise = mystica.noise.NoiseDynRel(...
        'stgsNoise',stgs.noise,...
        'controller_dt',stgs.integrator.maxTimeStep,...
        'kBaum',stgs.integrator.dxdtParam.baumgarteIntegralCoefficient,...
        'regTermDampPInv',stgs.integrator.dxdtParam.regTermDampPInv);
    stateDynNoise = noise.createStateDynMBodyNoise('stateDynMBody',stateDyn);

    data  = mystica.log.LoggerDynRel(...
        'model',model,...
        'stateDynMBody',stateDyn,...
        'numberIterations',length(kVec),...
        'stgsIntegrator',stgs.integrator);

    %% Integration

    for k = kVec
        % Controller
        motorsCurrent = contr.solve('stateDynMBody',stateDynNoise,'time',tout(k),'model',model,'mBodyVelAcc',intgr.get_dxdt()) * stgs.controller.applyControlInput;
        motorsCurrentNoise = noise.applyInputCompression('motorsCurrent',motorsCurrent);
        % Integrator
        mBodyPosVel_0 = intgr.integrate('stateDynMBody',stateDyn,'motorsCurrent',motorsCurrentNoise,'model',model);
        % Logger
        data.store('indexIteration',k,'time',tout(k),'model',model,'controller',contr,'stateDynMBody',stateDyn,'motorsCurrent',motorsCurrent,...
            'motorsAngVel_des',contr.motorsAngVel,...
            'motorsCurrent_gravity',contr.motorsCurrent_gravity,...
            'motorsCurrent_task',contr.motorsCurrent_task,...
            'motorsCurrentNoise',motorsCurrentNoise,...
            'stgsDesiredShape',stgs.desiredShape)
        % New State
        stateDyn.setMBodyPosVel('mBodyPosVel_0',mBodyPosVel_0,'model',model);
        stateDynNoise = noise.applyEstimationError('model',model,'stateDynMBody',stateDyn);
    end

    stats = mp.getPerformance();

    %% Saving Workspace

    clear ans k kVec motorsCurrent mBodyPosQuat_0 tout mp

    if stgs.saving.workspace.run
        if stgs.saving.workspace.clearCasadi
            contr.clearProperties();
            stateDyn.clearProperties();
        end
        save(stgs.saving.workspace.name)
    end

end
